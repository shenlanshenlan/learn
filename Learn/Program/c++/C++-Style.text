

*****头文件******
前置声明
尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
定义：
 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.

 内联函数
 只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 
 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.

头文件顺序
 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖:
  相关头文件, 顺序
  1C 库, 
  2C++ 库, 
  3其他库的 .h, 
  4本项目内的 .h.
  在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯。
 


  ******作用域************************************
  命名空间
  不应该使用 using 引入整个命名空间的标识符号

局部变量
C++ 允许在函数的任何位置声明变量. 
 我们提倡在尽可能小的作用域中声明变量,
 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置,
 了解变量的类型和初始值. 
 特别是，应使用初始化的方式替代声明再赋值 
 int i= 10;注意别在循环犯大量构造和析构的低级错误。

 [禁止使用类的 静态储存周期 变量]
 （静态变量 不能是类的 对象 只能是原生数据）
 即包括了全局变量，静态变量，静态类成员变量和函数静态变量，
 都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float,
 以及 POD 类型的指针、数组和结构体。
 综上所述，我们只允许 POD 类型的静态变量，即完全禁用 vector
  (使用 C 数组替代) 和 string (使用 const char [])。




*********类***********************************************
构造函数：
    不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.
隐式类型转换
     不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit（c11) 关键字.       
可拷贝类型和可移动类型
      如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.

结构体 vs 类
仅当只有数据成员时使用 struct, 其它一概使用 class.

继承
      使用组合 常常比使用继承更合理
[继承主要用于两种场合]: 1实现继承,子类继承父类的实现代码;
                     2接口继承,子类仅继承父类的方法名称.
析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数.
对于可能被子类访问的成员函数, 不要过度使用 protected 关键字. 
####注意, 数据成员都必须是 私有的.

接口
当一个类满足以下要求时, 称之为纯接口:
    只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数).
    没有非静态数据成员.
    没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected.
    如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.

运算符重载
    除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.

存取控制
      将 所有 数据成员声明为 private,
声明顺序
      类定义一般应以 public: 开始, 后跟 protected:, 最后是 private:. 省略空部分.

*******************函数********************************************************* 
参数顺序
      函数的参数顺序为: 输入参数在先, 后跟输出参数.
编写简短函数
      我们倾向于编写简短, 凝练的函数.
引用参数
      在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 int foo(int *pval). 
      在 C++ 中, 函数还可以声明为引用参数: int foo(int &val).
 函数返回类型后置语法
      auto foo(int x) -> int;（不推荐）
      
****************来自google的奇迹********************************************

******************其他*****************************************************
异常
     我们不使用 C++ 异常.
 提到当构造失败时只有异常可以处理,
运行时类型识别
      RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 typeid 或者 dynamic_cast 完成
类型转换
      使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;
前置自增和自减
      对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.
const 用法
      在声明的变量或参数前加上关键字 const 用于指明变量值不可被篡改 (如 const int foo ).
       为类中的函数加上 const 限定符表明该函数不会修改类成员变量的状态
 整型
      C++ 没有指定整型的大小. 通常人们假定 short 是 16 位, int 是 32 位, long 是 32 位, long long 是 64 位.
预处理宏
     宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.
        不要在 .h 文件中定义宏.
        在马上要使用时才进行 #define, 使用后要立即 #undef.
        不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；
        不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.
        不要用 ## 处理函数，类和变量的名字。
auto
      C++11 中，若变量被声明成 auto, 那它的类型就会被自动匹配成初始化表达式的类型。
      您可以用 auto 来复制初始化或绑定引用。
      vector<string> v;
      auto s1 = v[0];  // 创建一份 v[0] 的拷贝。
      const auto& s2 = v[0];  // s2 是 v[0] 的一个引用。
列表初始化
      早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：

*************************************7. 命名约定***********************
函数命名, 变量命名, 文件命名要有描述性; 少用缩写.
类型命名
      类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.
变量命名
      变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 
      如: a_local_variable, a_struct_data_member, a_class_data_member_.
函数命名
      常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: 
      MyExcitingFunction(), MyExcitingMethod(), 
      my_exciting_member_variable(), set_my_exciting_member_variable().


*************************************注释***********************
文件注释
类注释
      每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.
      类注释应当为读者理解如何使用与何时使用类提供足够的信息, 
      同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明.
       如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.
函数声明
     函数声明处注释的内容:
    函数的输入输出.
    对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.
    函数是否分配了必须由调用者释放的空间.
    参数是否可以为空指针.
    是否存在函数使用上的性能隐患.
    如果函数是可重入的, 其同步前提是什么?
 函数定义
     如果函数的实现过程中用到了很巧妙的方式, 
     那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 
     实现的大致步骤, 或解释如此实现的理由. 举个例子, 
     你可以说明为什么函数的前半部分要加锁而后半部分不需要.
类数据成员

实现注释  
      对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.
TODO 注释
       对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释.     
译者 (YuleFox) 笔记
    关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;
    文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;
    注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;
    对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；
    注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;
    TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.

****************************格式**************************************
每一行代码字符数不超过 80.
注意以下几点:
    使用好的参数名.
    只有在参数未被使用或者其用途非常明显时, 才能省略参数名.
    如果返回类型和函数名在一行放不下, 分行.
    如果返回类型与函数声明或定义分行了, 不要缩进.
    左圆括号总是和函数名在同一行.
   #函数名和左圆括号间永远没有空格.
   #圆括号与参数间没有空格.
   #左大括号总在最后一个参数同一行的末尾处, 不另起新行.
   #右大括号总是单独位于函数最后一行, 或者与左大括号同一行.
   #右圆括号和左大括号间总是有一个空格.
    所有形参应尽可能对齐.
    缺省缩进为 2 个空格.
    换行后的参数保持 4 个空格的缩进.
条件语句
      倾向于不在圆括号内使用空格. 关键字 if 和 else 另起一行.
      if (condition) {  // 圆括号里没有空格.
  ...  // 2 空格缩进.
} else if (...) {  // else 与 if 的右括号同一行.
  ...
} else {
  ...
}
通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 
复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号:
只要其中一个分支用了大括号, 两个分支都要用上大括号.

循环 
      空循环体应使用 {} 或 continue, 而不是一个简单的分号.
函数返回值
      只有在写 x = expr 要加上括号的时候才在 return expr; 里使用括号.
