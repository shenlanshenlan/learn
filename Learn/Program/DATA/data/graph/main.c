/*
图   通过数据 （V,E)构建图 （邻接表）
*/
#include "graph.h"
#include <stdio.h>
int main() {
 char* s2 = (
"       0A---->E2             \n"
"       / \\    /\\           \n"
"      v   v v   v            \n"
"     B<----D<----F           \n"
"    1\\   3/ \\   /6         \n"
"       v v   v v             \n"
"       4C<---G5              \n"
        );
  //V (此处用数组代替了散列表,注意区别)
char *vertex[7];    
     vertex[0] = "A";
     vertex[1] = "B";
     vertex[2] = "E";
     vertex[3] = "D";
     vertex[4] = "C";   
     vertex[5] = "G";   
     vertex[6] = "F";   

//E  关系集合 2个为一对
//E  的录入先后关系是否有影响？？？
int edge[] = {
0,1,  0,2,  0,3,  1,4,  2,3,  2,6,  3,1,  3,4,   3,5,  5,4,  6,5
}; 




printf("%s",s2);
Graph k =Load(k,edge,7,22) ;
display(k,7,vertex);
printf("top sort\n");
Top_Sort(k,edge,7,22);
/*大坑 邻接表最后一个节点5 并为生成头节点
  所以 入队时 其是一个空节点
  另 c 真的没效率 慢死了

################top sort 核心思路###################
用数组记录所有顶点入度
将入度为零的节点放入队列（注意放入的是头节点，不是邻接节点）
出队一个节点将其邻接节点入度都减1 ，减完以后入度为零的节点重新入队
循环
出队的顺序就是top 排序的顺序
*/
/*###############广度优先###################
三个属性
1 known   
2 dist
3 path 
*/
BFS(k,2,7);


}
 //打印邻接表


